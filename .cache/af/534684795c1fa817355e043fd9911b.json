{"id":"../node_modules/@aws-sdk/middleware-retry/build/defaultStrategy.js","dependencies":[{"name":"/Users/a/Desktop/buildopsTest/package.json","includedInParent":true,"mtime":1588279417247},{"name":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/package.json","includedInParent":true,"mtime":1588279428056},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/build/defaultStrategy.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/tslib/tslib.es6.js"},{"name":"./constants","loc":{"line":4,"column":26},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/build/defaultStrategy.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/build/constants.js"},{"name":"./delayDecider","loc":{"line":5,"column":29},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/build/defaultStrategy.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/build/delayDecider.js"},{"name":"./retryDecider","loc":{"line":6,"column":29},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/build/defaultStrategy.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/build/retryDecider.js"},{"name":"@aws-sdk/service-error-classification","loc":{"line":7,"column":45},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/middleware-retry/build/defaultStrategy.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/service-error-classification/build/index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar constants_1 = require(\"./constants\");\nvar delayDecider_1 = require(\"./delayDecider\");\nvar retryDecider_1 = require(\"./retryDecider\");\nvar service_error_classification_1 = require(\"@aws-sdk/service-error-classification\");\nvar ExponentialBackOffStrategy = /** @class */ (function () {\n    function ExponentialBackOffStrategy(maxRetries, retryDecider, delayDecider) {\n        if (retryDecider === void 0) { retryDecider = retryDecider_1.defaultRetryDecider; }\n        if (delayDecider === void 0) { delayDecider = delayDecider_1.defaultDelayDecider; }\n        this.maxRetries = maxRetries;\n        this.retryDecider = retryDecider;\n        this.delayDecider = delayDecider;\n    }\n    ExponentialBackOffStrategy.prototype.shouldRetry = function (error, retryAttempted) {\n        return retryAttempted < this.maxRetries && this.retryDecider(error);\n    };\n    ExponentialBackOffStrategy.prototype.retry = function (next, args) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var retries, totalDelay, _loop_1, this_1, state_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        retries = 0;\n                        totalDelay = 0;\n                        _loop_1 = function () {\n                            var _a, response, output, err_1, delay_1;\n                            return tslib_1.__generator(this, function (_b) {\n                                switch (_b.label) {\n                                    case 0:\n                                        _b.trys.push([0, 2, , 5]);\n                                        return [4 /*yield*/, next(args)];\n                                    case 1:\n                                        _a = _b.sent(), response = _a.response, output = _a.output;\n                                        output.$metadata.retries = retries;\n                                        output.$metadata.totalRetryDelay = totalDelay;\n                                        return [2 /*return*/, { value: { response: response, output: output } }];\n                                    case 2:\n                                        err_1 = _b.sent();\n                                        if (!this_1.shouldRetry(err_1, retries)) return [3 /*break*/, 4];\n                                        delay_1 = this_1.delayDecider(service_error_classification_1.isThrottlingError(err_1)\n                                            ? constants_1.THROTTLING_RETRY_DELAY_BASE\n                                            : constants_1.DEFAULT_RETRY_DELAY_BASE, retries++);\n                                        totalDelay += delay_1;\n                                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, delay_1); })];\n                                    case 3:\n                                        _b.sent();\n                                        return [2 /*return*/, \"continue\"];\n                                    case 4:\n                                        if (!err_1.$metadata) {\n                                            err_1.$metadata = {};\n                                        }\n                                        err_1.$metadata.retries = retries;\n                                        err_1.$metadata.totalRetryDelay = totalDelay;\n                                        throw err_1;\n                                    case 5: return [2 /*return*/];\n                                }\n                            });\n                        };\n                        this_1 = this;\n                        _a.label = 1;\n                    case 1:\n                        if (!true) return [3 /*break*/, 3];\n                        return [5 /*yield**/, _loop_1()];\n                    case 2:\n                        state_1 = _a.sent();\n                        if (typeof state_1 === \"object\")\n                            return [2 /*return*/, state_1.value];\n                        return [3 /*break*/, 1];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return ExponentialBackOffStrategy;\n}());\nexports.ExponentialBackOffStrategy = ExponentialBackOffStrategy;\n"},"sourceMaps":{"js":{"version":3,"file":"defaultStrategy.js","sourceRoot":"","sources":["../src/defaultStrategy.ts"],"names":[],"mappings":";;;AAAA,yCAGqB;AACrB,+CAAqD;AACrD,+CAAqD;AACrD,sFAA0E;AA6B1E;IACE,oCACkB,UAAkB,EAC1B,YAAgD,EAChD,YAAgD;QADhD,6BAAA,EAAA,eAA6B,kCAAmB;QAChD,6BAAA,EAAA,eAA6B,kCAAmB;QAFxC,eAAU,GAAV,UAAU,CAAQ;QAC1B,iBAAY,GAAZ,YAAY,CAAoC;QAChD,iBAAY,GAAZ,YAAY,CAAoC;IACvD,CAAC;IACI,gDAAW,GAAnB,UAAoB,KAAe,EAAE,cAAsB;QACzD,OAAO,cAAc,GAAG,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;IACtE,CAAC;IAEK,0CAAK,GAAX,UACE,IAAmC,EACnC,IAAqC;;;;;;wBAEjC,OAAO,GAAG,CAAC,CAAC;wBACZ,UAAU,GAAG,CAAC,CAAC;;;;;;;wCAGc,qBAAM,IAAI,CAAC,IAAI,CAAC,EAAA;;wCAAvC,KAAuB,SAAgB,EAArC,QAAQ,cAAA,EAAE,MAAM,YAAA;wCACxB,MAAM,CAAC,SAAS,CAAC,OAAO,GAAG,OAAO,CAAC;wCACnC,MAAM,CAAC,SAAS,CAAC,eAAe,GAAG,UAAU,CAAC;uEAEvC,EAAE,QAAQ,UAAA,EAAE,MAAM,QAAA,EAAE;;;6CAEvB,OAAK,WAAW,CAAC,KAAe,EAAE,OAAO,CAAC,EAA1C,wBAA0C;wCACtC,UAAQ,OAAK,YAAY,CAC7B,gDAAiB,CAAC,KAAG,CAAC;4CACpB,CAAC,CAAC,uCAA2B;4CAC7B,CAAC,CAAC,oCAAwB,EAC5B,OAAO,EAAE,CACV,CAAC;wCACF,UAAU,IAAI,OAAK,CAAC;wCAEpB,qBAAM,IAAI,OAAO,CAAC,UAAA,OAAO,IAAI,OAAA,UAAU,CAAC,OAAO,EAAE,OAAK,CAAC,EAA1B,CAA0B,CAAC,EAAA;;wCAAxD,SAAwD,CAAC;;;wCAI3D,IAAI,CAAC,KAAG,CAAC,SAAS,EAAE;4CAClB,KAAG,CAAC,SAAS,GAAG,EAAE,CAAC;yCACpB;wCAED,KAAG,CAAC,SAAS,CAAC,OAAO,GAAG,OAAO,CAAC;wCAChC,KAAG,CAAC,SAAS,CAAC,eAAe,GAAG,UAAU,CAAC;wCAC3C,MAAM,KAAG,CAAC;;;;;;;;6BA3BP,IAAI;;;;;;;;;;;KA8BZ;IACH,iCAAC;AAAD,CAAC,AA/CD,IA+CC;AA/CY,gEAA0B","sourcesContent":["import {\n  DEFAULT_RETRY_DELAY_BASE,\n  THROTTLING_RETRY_DELAY_BASE\n} from \"./constants\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport {\n  SdkError,\n  FinalizeHandler,\n  MetadataBearer,\n  FinalizeHandlerArguments,\n  RetryStrategy\n} from \"@aws-sdk/types\";\n\n/**\n * Determines whether an error is retryable based on the number of retries\n * already attempted, the HTTP status code, and the error received (if any).\n *\n * @param error         The error encountered.\n */\nexport interface RetryDecider {\n  (error: SdkError): boolean;\n}\n\n/**\n * Determines the number of milliseconds to wait before retrying an action.\n *\n * @param delayBase The base delay (in milliseconds).\n * @param attempts  The number of times the action has already been tried.\n */\nexport interface DelayDecider {\n  (delayBase: number, attempts: number): number;\n}\n\nexport class ExponentialBackOffStrategy implements RetryStrategy {\n  constructor(\n    public readonly maxRetries: number,\n    private retryDecider: RetryDecider = defaultRetryDecider,\n    private delayDecider: DelayDecider = defaultDelayDecider\n  ) {}\n  private shouldRetry(error: SdkError, retryAttempted: number) {\n    return retryAttempted < this.maxRetries && this.retryDecider(error);\n  }\n\n  async retry<Input extends object, Ouput extends MetadataBearer>(\n    next: FinalizeHandler<Input, Ouput>,\n    args: FinalizeHandlerArguments<Input>\n  ) {\n    let retries = 0;\n    let totalDelay = 0;\n    while (true) {\n      try {\n        const { response, output } = await next(args);\n        output.$metadata.retries = retries;\n        output.$metadata.totalRetryDelay = totalDelay;\n\n        return { response, output };\n      } catch (err) {\n        if (this.shouldRetry(err as SdkError, retries)) {\n          const delay = this.delayDecider(\n            isThrottlingError(err)\n              ? THROTTLING_RETRY_DELAY_BASE\n              : DEFAULT_RETRY_DELAY_BASE,\n            retries++\n          );\n          totalDelay += delay;\n\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        }\n\n        if (!err.$metadata) {\n          err.$metadata = {};\n        }\n\n        err.$metadata.retries = retries;\n        err.$metadata.totalRetryDelay = totalDelay;\n        throw err;\n      }\n    }\n  }\n}\n"]}},"error":null,"hash":"1c0f25c324a5bcd3a67abf71c82484da","cacheData":{"env":{}}}