{"id":"../node_modules/@aws-sdk/eventstream-marshaller/build/HeaderMarshaller.js","dependencies":[{"name":"/Users/a/Desktop/buildopsTest/package.json","includedInParent":true,"mtime":1588279417247},{"name":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/eventstream-marshaller/package.json","includedInParent":true,"mtime":1588279428040},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/eventstream-marshaller/build/HeaderMarshaller.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/tslib/tslib.es6.js"},{"name":"@aws-sdk/util-hex-encoding","loc":{"line":4,"column":34},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/eventstream-marshaller/build/HeaderMarshaller.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/util-hex-encoding/build/index.js"},{"name":"./Int64","loc":{"line":5,"column":22},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/eventstream-marshaller/build/HeaderMarshaller.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/eventstream-marshaller/build/Int64.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_hex_encoding_1 = require(\"@aws-sdk/util-hex-encoding\");\nvar Int64_1 = require(\"./Int64\");\n/**\n * @internal\n */\nvar HeaderMarshaller = /** @class */ (function () {\n    function HeaderMarshaller(toUtf8, fromUtf8) {\n        this.toUtf8 = toUtf8;\n        this.fromUtf8 = fromUtf8;\n    }\n    HeaderMarshaller.prototype.format = function (headers) {\n        var e_1, _a, e_2, _b;\n        var chunks = [];\n        try {\n            for (var _c = tslib_1.__values(Object.keys(headers)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var headerName = _d.value;\n                var bytes = this.fromUtf8(headerName);\n                chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var out = new Uint8Array(chunks.reduce(function (carry, bytes) { return carry + bytes.byteLength; }, 0));\n        var position = 0;\n        try {\n            for (var chunks_1 = tslib_1.__values(chunks), chunks_1_1 = chunks_1.next(); !chunks_1_1.done; chunks_1_1 = chunks_1.next()) {\n                var chunk = chunks_1_1.value;\n                out.set(chunk, position);\n                position += chunk.byteLength;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (chunks_1_1 && !chunks_1_1.done && (_b = chunks_1.return)) _b.call(chunks_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return out;\n    };\n    HeaderMarshaller.prototype.formatHeaderValue = function (header) {\n        switch (header.type) {\n            case \"boolean\":\n                return Uint8Array.from([\n                    header.value\n                        ? 0 /* boolTrue */\n                        : 1 /* boolFalse */\n                ]);\n            case \"byte\":\n                return Uint8Array.from([2 /* byte */, header.value]);\n            case \"short\":\n                var shortView = new DataView(new ArrayBuffer(3));\n                shortView.setUint8(0, 3 /* short */);\n                shortView.setInt16(1, header.value, false);\n                return new Uint8Array(shortView.buffer);\n            case \"integer\":\n                var intView = new DataView(new ArrayBuffer(5));\n                intView.setUint8(0, 4 /* integer */);\n                intView.setInt32(1, header.value, false);\n                return new Uint8Array(intView.buffer);\n            case \"long\":\n                var longBytes = new Uint8Array(9);\n                longBytes[0] = 5 /* long */;\n                longBytes.set(header.value.bytes, 1);\n                return longBytes;\n            case \"binary\":\n                var binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n                binView.setUint8(0, 6 /* byteArray */);\n                binView.setUint16(1, header.value.byteLength, false);\n                var binBytes = new Uint8Array(binView.buffer);\n                binBytes.set(header.value, 3);\n                return binBytes;\n            case \"string\":\n                var utf8Bytes = this.fromUtf8(header.value);\n                var strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n                strView.setUint8(0, 7 /* string */);\n                strView.setUint16(1, utf8Bytes.byteLength, false);\n                var strBytes = new Uint8Array(strView.buffer);\n                strBytes.set(utf8Bytes, 3);\n                return strBytes;\n            case \"timestamp\":\n                var tsBytes = new Uint8Array(9);\n                tsBytes[0] = 8 /* timestamp */;\n                tsBytes.set(Int64_1.Int64.fromNumber(header.value.valueOf()).bytes, 1);\n                return tsBytes;\n            case \"uuid\":\n                if (!UUID_PATTERN.test(header.value)) {\n                    throw new Error(\"Invalid UUID received: \" + header.value);\n                }\n                var uuidBytes = new Uint8Array(17);\n                uuidBytes[0] = 9 /* uuid */;\n                uuidBytes.set(util_hex_encoding_1.fromHex(header.value.replace(/\\-/g, \"\")), 1);\n                return uuidBytes;\n        }\n    };\n    HeaderMarshaller.prototype.parse = function (headers) {\n        var out = {};\n        var position = 0;\n        while (position < headers.byteLength) {\n            var nameLength = headers.getUint8(position++);\n            var name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n            position += nameLength;\n            switch (headers.getUint8(position++)) {\n                case 0 /* boolTrue */:\n                    out[name] = {\n                        type: BOOLEAN_TAG,\n                        value: true\n                    };\n                    break;\n                case 1 /* boolFalse */:\n                    out[name] = {\n                        type: BOOLEAN_TAG,\n                        value: false\n                    };\n                    break;\n                case 2 /* byte */:\n                    out[name] = {\n                        type: BYTE_TAG,\n                        value: headers.getInt8(position++)\n                    };\n                    break;\n                case 3 /* short */:\n                    out[name] = {\n                        type: SHORT_TAG,\n                        value: headers.getInt16(position, false)\n                    };\n                    position += 2;\n                    break;\n                case 4 /* integer */:\n                    out[name] = {\n                        type: INT_TAG,\n                        value: headers.getInt32(position, false)\n                    };\n                    position += 4;\n                    break;\n                case 5 /* long */:\n                    out[name] = {\n                        type: LONG_TAG,\n                        value: new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))\n                    };\n                    position += 8;\n                    break;\n                case 6 /* byteArray */:\n                    var binaryLength = headers.getUint16(position, false);\n                    position += 2;\n                    out[name] = {\n                        type: BINARY_TAG,\n                        value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)\n                    };\n                    position += binaryLength;\n                    break;\n                case 7 /* string */:\n                    var stringLength = headers.getUint16(position, false);\n                    position += 2;\n                    out[name] = {\n                        type: STRING_TAG,\n                        value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))\n                    };\n                    position += stringLength;\n                    break;\n                case 8 /* timestamp */:\n                    out[name] = {\n                        type: TIMESTAMP_TAG,\n                        value: new Date(new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())\n                    };\n                    position += 8;\n                    break;\n                case 9 /* uuid */:\n                    var uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n                    position += 16;\n                    out[name] = {\n                        type: UUID_TAG,\n                        value: util_hex_encoding_1.toHex(uuidBytes.subarray(0, 4)) + \"-\" + util_hex_encoding_1.toHex(uuidBytes.subarray(4, 6)) + \"-\" + util_hex_encoding_1.toHex(uuidBytes.subarray(6, 8)) + \"-\" + util_hex_encoding_1.toHex(uuidBytes.subarray(8, 10)) + \"-\" + util_hex_encoding_1.toHex(uuidBytes.subarray(10))\n                    };\n                    break;\n                default:\n                    throw new Error(\"Unrecognized header type tag\");\n            }\n        }\n        return out;\n    };\n    return HeaderMarshaller;\n}());\nexports.HeaderMarshaller = HeaderMarshaller;\nvar BOOLEAN_TAG = \"boolean\";\nvar BYTE_TAG = \"byte\";\nvar SHORT_TAG = \"short\";\nvar INT_TAG = \"integer\";\nvar LONG_TAG = \"long\";\nvar BINARY_TAG = \"binary\";\nvar STRING_TAG = \"string\";\nvar TIMESTAMP_TAG = \"timestamp\";\nvar UUID_TAG = \"uuid\";\nvar UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;\n"},"sourceMaps":{"js":{"version":3,"file":"HeaderMarshaller.js","sourceRoot":"","sources":["../src/HeaderMarshaller.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Decoder,\n  Encoder,\n  MessageHeaders,\n  MessageHeaderValue\n} from \"@aws-sdk/types\";\nimport { fromHex, toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { Int64 } from \"./Int64\";\n\n/**\n * @internal\n */\nexport class HeaderMarshaller {\n  constructor(\n    private readonly toUtf8: Encoder,\n    private readonly fromUtf8: Decoder\n  ) {}\n\n  format(headers: MessageHeaders): Uint8Array {\n    const chunks: Array<Uint8Array> = [];\n\n    for (const headerName of Object.keys(headers)) {\n      const bytes = this.fromUtf8(headerName);\n      chunks.push(\n        Uint8Array.from([bytes.byteLength]),\n        bytes,\n        this.formatHeaderValue(headers[headerName])\n      );\n    }\n\n    const out = new Uint8Array(\n      chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0)\n    );\n    let position = 0;\n    for (const chunk of chunks) {\n      out.set(chunk, position);\n      position += chunk.byteLength;\n    }\n\n    return out;\n  }\n\n  private formatHeaderValue(header: MessageHeaderValue): Uint8Array {\n    switch (header.type) {\n      case \"boolean\":\n        return Uint8Array.from([\n          header.value\n            ? HEADER_VALUE_TYPE.boolTrue\n            : HEADER_VALUE_TYPE.boolFalse\n        ]);\n      case \"byte\":\n        return Uint8Array.from([HEADER_VALUE_TYPE.byte, header.value]);\n      case \"short\":\n        const shortView = new DataView(new ArrayBuffer(3));\n        shortView.setUint8(0, HEADER_VALUE_TYPE.short);\n        shortView.setInt16(1, header.value, false);\n        return new Uint8Array(shortView.buffer);\n      case \"integer\":\n        const intView = new DataView(new ArrayBuffer(5));\n        intView.setUint8(0, HEADER_VALUE_TYPE.integer);\n        intView.setInt32(1, header.value, false);\n        return new Uint8Array(intView.buffer);\n      case \"long\":\n        const longBytes = new Uint8Array(9);\n        longBytes[0] = HEADER_VALUE_TYPE.long;\n        longBytes.set(header.value.bytes, 1);\n        return longBytes;\n      case \"binary\":\n        const binView = new DataView(\n          new ArrayBuffer(3 + header.value.byteLength)\n        );\n        binView.setUint8(0, HEADER_VALUE_TYPE.byteArray);\n        binView.setUint16(1, header.value.byteLength, false);\n        const binBytes = new Uint8Array(binView.buffer);\n        binBytes.set(header.value, 3);\n        return binBytes;\n      case \"string\":\n        const utf8Bytes = this.fromUtf8(header.value);\n        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n        strView.setUint8(0, HEADER_VALUE_TYPE.string);\n        strView.setUint16(1, utf8Bytes.byteLength, false);\n        const strBytes = new Uint8Array(strView.buffer);\n        strBytes.set(utf8Bytes, 3);\n        return strBytes;\n      case \"timestamp\":\n        const tsBytes = new Uint8Array(9);\n        tsBytes[0] = HEADER_VALUE_TYPE.timestamp;\n        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n        return tsBytes;\n      case \"uuid\":\n        if (!UUID_PATTERN.test(header.value)) {\n          throw new Error(`Invalid UUID received: ${header.value}`);\n        }\n\n        const uuidBytes = new Uint8Array(17);\n        uuidBytes[0] = HEADER_VALUE_TYPE.uuid;\n        uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n        return uuidBytes;\n    }\n  }\n\n  parse(headers: DataView): MessageHeaders {\n    const out: MessageHeaders = {};\n    let position = 0;\n\n    while (position < headers.byteLength) {\n      const nameLength = headers.getUint8(position++);\n      const name = this.toUtf8(\n        new Uint8Array(\n          headers.buffer,\n          headers.byteOffset + position,\n          nameLength\n        )\n      );\n      position += nameLength;\n\n      switch (headers.getUint8(position++)) {\n        case HEADER_VALUE_TYPE.boolTrue:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: true\n          };\n          break;\n        case HEADER_VALUE_TYPE.boolFalse:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: false\n          };\n          break;\n        case HEADER_VALUE_TYPE.byte:\n          out[name] = {\n            type: BYTE_TAG,\n            value: headers.getInt8(position++)\n          };\n          break;\n        case HEADER_VALUE_TYPE.short:\n          out[name] = {\n            type: SHORT_TAG,\n            value: headers.getInt16(position, false)\n          };\n          position += 2;\n          break;\n        case HEADER_VALUE_TYPE.integer:\n          out[name] = {\n            type: INT_TAG,\n            value: headers.getInt32(position, false)\n          };\n          position += 4;\n          break;\n        case HEADER_VALUE_TYPE.long:\n          out[name] = {\n            type: LONG_TAG,\n            value: new Int64(\n              new Uint8Array(headers.buffer, headers.byteOffset + position, 8)\n            )\n          };\n          position += 8;\n          break;\n        case HEADER_VALUE_TYPE.byteArray:\n          const binaryLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: BINARY_TAG,\n            value: new Uint8Array(\n              headers.buffer,\n              headers.byteOffset + position,\n              binaryLength\n            )\n          };\n          position += binaryLength;\n          break;\n        case HEADER_VALUE_TYPE.string:\n          const stringLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: STRING_TAG,\n            value: this.toUtf8(\n              new Uint8Array(\n                headers.buffer,\n                headers.byteOffset + position,\n                stringLength\n              )\n            )\n          };\n          position += stringLength;\n          break;\n        case HEADER_VALUE_TYPE.timestamp:\n          out[name] = {\n            type: TIMESTAMP_TAG,\n            value: new Date(\n              new Int64(\n                new Uint8Array(headers.buffer, headers.byteOffset + position, 8)\n              ).valueOf()\n            )\n          };\n          position += 8;\n          break;\n        case HEADER_VALUE_TYPE.uuid:\n          const uuidBytes = new Uint8Array(\n            headers.buffer,\n            headers.byteOffset + position,\n            16\n          );\n          position += 16;\n          out[name] = {\n            type: UUID_TAG,\n            value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(\n              uuidBytes.subarray(4, 6)\n            )}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(\n              uuidBytes.subarray(8, 10)\n            )}-${toHex(uuidBytes.subarray(10))}`\n          };\n          break;\n        default:\n          throw new Error(`Unrecognized header type tag`);\n      }\n    }\n\n    return out;\n  }\n}\n\nconst enum HEADER_VALUE_TYPE {\n  boolTrue = 0,\n  boolFalse,\n  byte,\n  short,\n  integer,\n  long,\n  byteArray,\n  string,\n  timestamp,\n  uuid\n}\n\nconst BOOLEAN_TAG = \"boolean\";\nconst BYTE_TAG = \"byte\";\nconst SHORT_TAG = \"short\";\nconst INT_TAG = \"integer\";\nconst LONG_TAG = \"long\";\nconst BINARY_TAG = \"binary\";\nconst STRING_TAG = \"string\";\nconst TIMESTAMP_TAG = \"timestamp\";\nconst UUID_TAG = \"uuid\";\n\nconst UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;\n"]}},"error":null,"hash":"41de6133898c1f4c83502106b98ca7dc","cacheData":{"env":{}}}