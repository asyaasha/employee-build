{"id":"../node_modules/@aws-amplify/predictions/node_modules/@aws-sdk/eventstream-marshaller/build/splitMessage.js","dependencies":[{"name":"/Users/a/Desktop/buildopsTest/package.json","includedInParent":true,"mtime":1588279417247},{"name":"/Users/a/Desktop/buildopsTest/node_modules/@aws-amplify/predictions/node_modules/@aws-sdk/eventstream-marshaller/package.json","includedInParent":true,"mtime":1588279428047},{"name":"@aws-crypto/crc32","loc":{"line":3,"column":22},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-amplify/predictions/node_modules/@aws-sdk/eventstream-marshaller/build/splitMessage.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/@aws-crypto/crc32/build/index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar crc32_1 = require(\"@aws-crypto/crc32\");\n// All prelude components are unsigned, 32-bit integers\nvar PRELUDE_MEMBER_LENGTH = 4;\n// The prelude consists of two components\nvar PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\n// Checksums are always CRC32 hashes.\nvar CHECKSUM_LENGTH = 4;\n// Messages must include a full prelude, a prelude checksum, and a message checksum\nvar MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\n/**\n * @internal\n */\nfunction splitMessage(_a) {\n    var byteLength = _a.byteLength, byteOffset = _a.byteOffset, buffer = _a.buffer;\n    if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n        throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n    }\n    var view = new DataView(buffer, byteOffset, byteLength);\n    var messageLength = view.getUint32(0, false);\n    if (byteLength !== messageLength) {\n        throw new Error(\"Reported message length does not match received message length\");\n    }\n    var headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n    var expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n    var expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n    var checksummer = new crc32_1.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n    if (expectedPreludeChecksum !== checksummer.digest()) {\n        throw new Error(\"The prelude checksum specified in the message (\" + expectedPreludeChecksum + \") does not match the calculated CRC32 checksum (\" + checksummer.digest() + \")\");\n    }\n    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));\n    if (expectedMessageChecksum !== checksummer.digest()) {\n        throw new Error(\"The message checksum (\" + checksummer.digest() + \") did not match the expected value of \" + expectedMessageChecksum);\n    }\n    return {\n        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength -\n            headerLength -\n            (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))\n    };\n}\nexports.splitMessage = splitMessage;\n"},"sourceMaps":{"js":{"version":3,"file":"splitMessage.js","sourceRoot":"","sources":["../src/splitMessage.ts"],"names":[],"mappings":";;AAAA,2CAA0C;AAE1C,uDAAuD;AACvD,IAAM,qBAAqB,GAAG,CAAC,CAAC;AAChC,yCAAyC;AACzC,IAAM,cAAc,GAAG,qBAAqB,GAAG,CAAC,CAAC;AACjD,qCAAqC;AACrC,IAAM,eAAe,GAAG,CAAC,CAAC;AAC1B,mFAAmF;AACnF,IAAM,sBAAsB,GAAG,cAAc,GAAG,eAAe,GAAG,CAAC,CAAC;AAUpE;;GAEG;AACH,SAAgB,YAAY,CAAC,EAIX;QAHhB,0BAAU,EACV,0BAAU,EACV,kBAAM;IAEN,IAAI,UAAU,GAAG,sBAAsB,EAAE;QACvC,MAAM,IAAI,KAAK,CACb,yEAAyE,CAC1E,CAAC;KACH;IAED,IAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,MAAM,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;IAE1D,IAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IAE/C,IAAI,UAAU,KAAK,aAAa,EAAE;QAChC,MAAM,IAAI,KAAK,CACb,gEAAgE,CACjE,CAAC;KACH;IAED,IAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,qBAAqB,EAAE,KAAK,CAAC,CAAC;IAClE,IAAM,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC;IACtE,IAAM,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAC5C,UAAU,GAAG,eAAe,EAC5B,KAAK,CACN,CAAC;IAEF,IAAM,WAAW,GAAG,IAAI,aAAK,EAAE,CAAC,MAAM,CACpC,IAAI,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,cAAc,CAAC,CACnD,CAAC;IACF,IAAI,uBAAuB,KAAK,WAAW,CAAC,MAAM,EAAE,EAAE;QACpD,MAAM,IAAI,KAAK,CACb,oDAAkD,uBAAuB,wDAAmD,WAAW,CAAC,MAAM,EAAE,MAAG,CACpJ,CAAC;KACH;IAED,WAAW,CAAC,MAAM,CAChB,IAAI,UAAU,CACZ,MAAM,EACN,UAAU,GAAG,cAAc,EAC3B,UAAU,GAAG,CAAC,cAAc,GAAG,eAAe,CAAC,CAChD,CACF,CAAC;IACF,IAAI,uBAAuB,KAAK,WAAW,CAAC,MAAM,EAAE,EAAE;QACpD,MAAM,IAAI,KAAK,CACb,2BAAyB,WAAW,CAAC,MAAM,EAAE,8CAAyC,uBAAyB,CAChH,CAAC;KACH;IAED,OAAO;QACL,OAAO,EAAE,IAAI,QAAQ,CACnB,MAAM,EACN,UAAU,GAAG,cAAc,GAAG,eAAe,EAC7C,YAAY,CACb;QACD,IAAI,EAAE,IAAI,UAAU,CAClB,MAAM,EACN,UAAU,GAAG,cAAc,GAAG,eAAe,GAAG,YAAY,EAC5D,aAAa;YACX,YAAY;YACZ,CAAC,cAAc,GAAG,eAAe,GAAG,eAAe,CAAC,CACvD;KACF,CAAC;AACJ,CAAC;AAhED,oCAgEC","sourcesContent":["import { Crc32 } from \"@aws-crypto/crc32\";\n\n// All prelude components are unsigned, 32-bit integers\nconst PRELUDE_MEMBER_LENGTH = 4;\n// The prelude consists of two components\nconst PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\n// Checksums are always CRC32 hashes.\nconst CHECKSUM_LENGTH = 4;\n// Messages must include a full prelude, a prelude checksum, and a message checksum\nconst MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\n\n/**\n * @internal\n */\nexport interface MessageParts {\n  headers: DataView;\n  body: Uint8Array;\n}\n\n/**\n * @internal\n */\nexport function splitMessage({\n  byteLength,\n  byteOffset,\n  buffer\n}: ArrayBufferView): MessageParts {\n  if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n    throw new Error(\n      \"Provided message too short to accommodate event stream message overhead\"\n    );\n  }\n\n  const view = new DataView(buffer, byteOffset, byteLength);\n\n  const messageLength = view.getUint32(0, false);\n\n  if (byteLength !== messageLength) {\n    throw new Error(\n      \"Reported message length does not match received message length\"\n    );\n  }\n\n  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n  const expectedMessageChecksum = view.getUint32(\n    byteLength - CHECKSUM_LENGTH,\n    false\n  );\n\n  const checksummer = new Crc32().update(\n    new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH)\n  );\n  if (expectedPreludeChecksum !== checksummer.digest()) {\n    throw new Error(\n      `The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`\n    );\n  }\n\n  checksummer.update(\n    new Uint8Array(\n      buffer,\n      byteOffset + PRELUDE_LENGTH,\n      byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)\n    )\n  );\n  if (expectedMessageChecksum !== checksummer.digest()) {\n    throw new Error(\n      `The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`\n    );\n  }\n\n  return {\n    headers: new DataView(\n      buffer,\n      byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH,\n      headerLength\n    ),\n    body: new Uint8Array(\n      buffer,\n      byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength,\n      messageLength -\n        headerLength -\n        (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)\n    )\n  };\n}\n"]}},"error":null,"hash":"7efa2ddb95bd4cf196856a27df245810","cacheData":{"env":{}}}