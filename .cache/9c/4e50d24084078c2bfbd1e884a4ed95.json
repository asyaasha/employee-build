{"id":"../node_modules/@aws-sdk/property-provider/build/memoize.js","dependencies":[{"name":"/Users/a/Desktop/buildopsTest/package.json","includedInParent":true,"mtime":1588363055010},{"name":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/property-provider/package.json","includedInParent":true,"mtime":1588306092108}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction memoize(provider, isExpired, requiresRefresh) {\n    if (isExpired === undefined) {\n        // This is a static memoization; no need to incorporate refreshing\n        var result_1 = provider();\n        return function () { return result_1; };\n    }\n    var result = provider();\n    var isConstant = false;\n    return function () {\n        if (isConstant) {\n            return result;\n        }\n        return result.then(function (resolved) {\n            if (requiresRefresh && !requiresRefresh(resolved)) {\n                isConstant = true;\n                return resolved;\n            }\n            if (isExpired(resolved)) {\n                return (result = provider());\n            }\n            return resolved;\n        });\n    };\n}\nexports.memoize = memoize;\n"},"sourceMaps":{"js":{"version":3,"file":"memoize.js","sourceRoot":"","sources":["../src/memoize.ts"],"names":[],"mappings":";;AAwCA,SAAgB,OAAO,CACrB,QAAqB,EACrB,SAAoC,EACpC,eAA0C;IAE1C,IAAI,SAAS,KAAK,SAAS,EAAE;QAC3B,kEAAkE;QAClE,IAAM,QAAM,GAAG,QAAQ,EAAE,CAAC;QAC1B,OAAO,cAAM,OAAA,QAAM,EAAN,CAAM,CAAC;KACrB;IAED,IAAI,MAAM,GAAG,QAAQ,EAAE,CAAC;IACxB,IAAI,UAAU,GAAY,KAAK,CAAC;IAEhC,OAAO;QACL,IAAI,UAAU,EAAE;YACd,OAAO,MAAM,CAAC;SACf;QAED,OAAO,MAAM,CAAC,IAAI,CAAC,UAAA,QAAQ;YACzB,IAAI,eAAe,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;gBACjD,UAAU,GAAG,IAAI,CAAC;gBAClB,OAAO,QAAQ,CAAC;aACjB;YAED,IAAI,SAAS,CAAC,QAAQ,CAAC,EAAE;gBACvB,OAAO,CAAC,MAAM,GAAG,QAAQ,EAAE,CAAC,CAAC;aAC9B;YAED,OAAO,QAAQ,CAAC;QAClB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AAhCD,0BAgCC","sourcesContent":["import { Provider } from \"@aws-sdk/types\";\n\n/**\n *\n * Decorates a provider function with either static memoization.\n *\n * To create a statically memoized provider, supply a provider as the only\n * argument to this function. The provider will be invoked once, and all\n * invocations of the provider returned by `memoize` will return the same\n * promise object.\n *\n * @param provider The provider whose result should be cached indefinitely.\n */\nexport function memoize<T>(provider: Provider<T>): Provider<T>;\n\n/**\n * Decorates a provider function with refreshing memoization.\n *\n * @param provider          The provider whose result should be cached.\n * @param isExpired         A function that will evaluate the resolved value and\n *                          determine if it is expired. For example, when\n *                          memoizing AWS credential providers, this function\n *                          should return `true` when the credential's\n *                          expiration is in the past (or very near future) and\n *                          `false` otherwise.\n * @param requiresRefresh   A function that will evaluate the resolved value and\n *                          determine if it represents static value or one that\n *                          will eventually need to be refreshed. For example,\n *                          AWS credentials that have no defined expiration will\n *                          never need to be refreshed, so this function would\n *                          return `true` if the credentials resolved by the\n *                          underlying provider had an expiration and `false`\n *                          otherwise.\n */\nexport function memoize<T>(\n  provider: Provider<T>,\n  isExpired: (resolved: T) => boolean,\n  requiresRefresh?: (resolved: T) => boolean\n): Provider<T>;\n\nexport function memoize<T>(\n  provider: Provider<T>,\n  isExpired?: (resolved: T) => boolean,\n  requiresRefresh?: (resolved: T) => boolean\n): Provider<T> {\n  if (isExpired === undefined) {\n    // This is a static memoization; no need to incorporate refreshing\n    const result = provider();\n    return () => result;\n  }\n\n  let result = provider();\n  let isConstant: boolean = false;\n\n  return () => {\n    if (isConstant) {\n      return result;\n    }\n\n    return result.then(resolved => {\n      if (requiresRefresh && !requiresRefresh(resolved)) {\n        isConstant = true;\n        return resolved;\n      }\n\n      if (isExpired(resolved)) {\n        return (result = provider());\n      }\n\n      return resolved;\n    });\n  };\n}\n"]}},"error":null,"hash":"9c2c0655cb58f97b9ea682b71dddbd07","cacheData":{"env":{}}}