{"id":"../node_modules/@aws-sdk/config-resolver/build/EndpointsConfig.js","dependencies":[{"name":"/Users/a/Desktop/buildopsTest/package.json","includedInParent":true,"mtime":1588355748633},{"name":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/config-resolver/package.json","includedInParent":true,"mtime":1588306092048},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/Users/a/Desktop/buildopsTest/node_modules/@aws-sdk/config-resolver/build/EndpointsConfig.js","resolved":"/Users/a/Desktop/buildopsTest/node_modules/tslib/tslib.es6.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nfunction normalizeEndpoint(endpoint, urlParser) {\n    if (typeof endpoint === \"string\") {\n        var promisified_1 = Promise.resolve(urlParser(endpoint));\n        return function () { return promisified_1; };\n    }\n    else if (typeof endpoint === \"object\") {\n        var promisified_2 = Promise.resolve(endpoint);\n        return function () { return promisified_2; };\n    }\n    return endpoint;\n}\nexports.normalizeEndpoint = normalizeEndpoint;\nfunction resolveEndpointsConfig(input) {\n    var _this = this;\n    var tls = input.tls === undefined ? true : input.tls;\n    var endpoint = input.endpoint\n        ? normalizeEndpoint(input.endpoint, input.urlParser)\n        : function () {\n            return input.region().then(function (region) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                var hostname, endpoint;\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, input.regionInfoProvider(region)];\n                        case 1:\n                            hostname = ((_a.sent()) || {}).hostname;\n                            if (!hostname) {\n                                throw new Error(\"Cannot resolve hostname from client config\");\n                            }\n                            endpoint = input.urlParser((tls ? \"https:\" : \"http:\") + \"//\" + hostname);\n                            return [2 /*return*/, endpoint];\n                    }\n                });\n            }); });\n        };\n    return tslib_1.__assign(tslib_1.__assign({}, input), { endpoint: endpoint,\n        tls: tls });\n}\nexports.resolveEndpointsConfig = resolveEndpointsConfig;\n"},"sourceMaps":{"js":{"version":3,"file":"EndpointsConfig.js","sourceRoot":"","sources":["../src/EndpointsConfig.ts"],"names":[],"mappings":";;;AAQA,SAAgB,iBAAiB,CAC/B,QAAiD,EACjD,SAAqB;IAErB,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QAChC,IAAM,aAAW,GAAG,OAAO,CAAC,OAAO,CAAC,SAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC1D,OAAO,cAAM,OAAA,aAAW,EAAX,CAAW,CAAC;KAC1B;SAAM,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QACvC,IAAM,aAAW,GAAG,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC9C,OAAO,cAAM,OAAA,aAAW,EAAX,CAAW,CAAC;KAC1B;IACD,OAAO,QAAS,CAAC;AACnB,CAAC;AAZD,8CAYC;AAsBD,SAAgB,sBAAsB,CACpC,KAAoD;IADtD,iBAwBC;IArBC,IAAM,GAAG,GAAG,KAAK,CAAC,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC;IACvD,IAAM,QAAQ,GAAuB,KAAK,CAAC,QAAQ;QACjD,CAAC,CAAC,iBAAiB,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,SAAS,CAAC;QACpD,CAAC,CAAC;YACE,OAAA,KAAK,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,UAAM,MAAM;;;;gCAE3B,qBAAM,KAAK,CAAC,kBAAkB,CAAC,MAAM,CAAC,EAAA;;4BADnC,QAAQ,GAAG,CACf,CAAC,SAAsC,CAAC,IAAK,EAAiB,CAC/D,CAAC,QAAQ;4BACV,IAAI,CAAC,QAAQ,EAAE;gCACb,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;6BAC/D;4BACK,QAAQ,GAAG,KAAK,CAAC,SAAS,CAC9B,CAAG,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,WAAK,QAAU,CAC3C,CAAC;4BACF,sBAAO,QAAQ,EAAC;;;iBACjB,CAAC;QAXF,CAWE,CAAC;IACT,6CACK,KAAK,KACR,QAAQ,UAAA;QACR,GAAG,KAAA,IACH;AACJ,CAAC;AAxBD,wDAwBC","sourcesContent":["import {\n  Provider,\n  UrlParser,\n  Endpoint,\n  RegionInfoProvider,\n  RegionInfo\n} from \"@aws-sdk/types\";\n\nexport function normalizeEndpoint(\n  endpoint?: string | Endpoint | Provider<Endpoint>,\n  urlParser?: UrlParser\n): Provider<Endpoint> {\n  if (typeof endpoint === \"string\") {\n    const promisified = Promise.resolve(urlParser!(endpoint));\n    return () => promisified;\n  } else if (typeof endpoint === \"object\") {\n    const promisified = Promise.resolve(endpoint);\n    return () => promisified;\n  }\n  return endpoint!;\n}\n\nexport interface EndpointsInputConfig {\n  /**\n   * The fully qualified endpoint of the webservice. This is only required when using a custom endpoint (for example, when using a local version of S3).\n   */\n  endpoint?: string | Endpoint | Provider<Endpoint>;\n\n  /**\n   * Whether TLS is enabled for requests.\n   */\n  tls?: boolean;\n}\ninterface PreviouslyResolved {\n  regionInfoProvider: RegionInfoProvider;\n  urlParser: UrlParser;\n  region: Provider<string>;\n}\nexport interface EndpointsResolvedConfig\n  extends Required<EndpointsInputConfig> {\n  endpoint: Provider<Endpoint>;\n}\nexport function resolveEndpointsConfig<T>(\n  input: T & EndpointsInputConfig & PreviouslyResolved\n): T & EndpointsResolvedConfig {\n  const tls = input.tls === undefined ? true : input.tls;\n  const endpoint: Provider<Endpoint> = input.endpoint\n    ? normalizeEndpoint(input.endpoint, input.urlParser)\n    : () =>\n        input.region().then(async region => {\n          const hostname = (\n            (await input.regionInfoProvider(region)) || ({} as RegionInfo)\n          ).hostname;\n          if (!hostname) {\n            throw new Error(\"Cannot resolve hostname from client config\");\n          }\n          const endpoint = input.urlParser(\n            `${tls ? \"https:\" : \"http:\"}//${hostname}`\n          );\n          return endpoint;\n        });\n  return {\n    ...input,\n    endpoint,\n    tls\n  };\n}\n"]}},"error":null,"hash":"dddeba0198804c9f1bf19e73560dceb3","cacheData":{"env":{}}}